# üìä Analyse Compl√®te de la Codebase Simplix - JWT Authentication

## ‚úÖ Ce qui est D√âJ√Ä IMPL√âMENT√â

### Backend API (auth.ts)
- ‚úÖ **POST /auth/register** - Cr√©ation de compte avec tokens
- ‚úÖ **POST /auth/login** - Connexion avec g√©n√©ration de paire de tokens
- ‚úÖ **POST /auth/refresh** - Renouvellement des tokens
- ‚úÖ **GET /auth/me** - R√©cup√©ration de l'utilisateur courant
- ‚úÖ **POST /auth/change-password** - Changement de mot de passe
- ‚úÖ **POST /auth/logout** - D√©connexion
- ‚úÖ **POST /auth/validate-password** - Validation de la force du mot de passe
- ‚úÖ Token Pair Generation (access + refresh)
- ‚úÖ JWT Token Verification
- ‚úÖ Refresh Token Storage en BD
- ‚úÖ Password Hashing (Bcrypt)

### Middleware (auth.ts)
- ‚úÖ `authenticateToken` - V√©rification JWT
- ‚úÖ `authorizeRole` - V√©rification des permissions
- ‚úÖ `requireOrganization` - Validation multi-tenancy
- ‚úÖ Validation du format JWT (3 parties)
- ‚úÖ Gestion d'erreurs JWT d√©taill√©e

### Frontend Services (api.ts)
- ‚úÖ Axios Instance avec configuration
- ‚úÖ Request Interceptor (ajoute token Bearer)
- ‚úÖ Response Interceptor (g√®re 401)
- ‚úÖ Service methods pour auth

### Frontend Context (AuthContext.tsx)
- ‚úÖ Login, Register, Logout
- ‚úÖ Change Password
- ‚úÖ Token & User Management
- ‚úÖ Auth State Management
- ‚úÖ Token Storage (AsyncStorage)

### Database
- ‚úÖ Migration 006_jwt_tokens.sql
- ‚úÖ Table refresh_tokens pour r√©vocation
- ‚úÖ Indexes pour performance

---

## ‚ùå CE QUI MANQUE

### 1. **Frontend - Refresh Token Handling MANQUANT**

**Probl√®me**: Le frontend n'impl√©mente PAS automatiquement le refresh des tokens
- L'accessToken expire apr√®s 15 minutes
- Pas de m√©canisme pour utiliser le refreshToken
- Les requ√™tes √©choueront apr√®s 15 minutes avec 401

**Fichier √† cr√©er/modifier**: `web-app/src/utils/tokenManager.ts` (NOUVEAU)

**Impact**: Token va expirer et l'utilisateur sera d√©connect√© sans pouvoir se reconnecter automatiquement

### 2. **Frontend - Refresh Token Storage MANQUANT**

**Probl√®me**: Le frontend ne stocke PAS le refreshToken
- Seul le accessToken est stock√©
- `authService.login()` ne stocke pas le refreshToken
- Impossible de rafra√Æchir le token

**Fichier √† modifier**: 
- `web-app/src/utils/storage.ts` - Ajouter `saveRefreshToken()`, `getRefreshToken()`
- `web-app/src/context/AuthContext.tsx` - Stocker le refreshToken re√ßu
- `web-app/src/services/api.ts` - Utiliser le refreshToken dans l'interceptor

**Code manquant**:
```typescript
// storage.ts - MANQUANT
async saveRefreshToken(refreshToken: string): Promise<void>
async getRefreshToken(): Promise<string | null>
```

```typescript
// AuthContext.tsx - MANQUANT
const login = async (email, password) => {
  const { token, refreshToken } = response.data;
  await storage.saveRefreshToken(refreshToken); // <- MANQUANT!
};
```

### 3. **Frontend - Token Refresh Interceptor Response MANQUANT**

**Probl√®me**: L'interceptor response ne g√®re PAS correctement le refresh
- Il d√©tecte bien le 401
- Mais il ne call pas `/auth/refresh`
- Il n'utilise pas le refreshToken pour obtenir un nouveau token

**Fichier √† modifier**: `web-app/src/services/api.ts`

**Code manquant**:
```typescript
api.interceptors.response.use(
  (response) => response,
  async (error) => {
    if (error.response?.status === 401) {
      try {
        const refreshToken = await storage.getRefreshToken(); // <- Besoin de cette fonction
        if (refreshToken) {
          // Appeler POST /auth/refresh <- MANQUANT
          // Mettre √† jour le token <- MANQUANT
          // Retry la requ√™te <- MANQUANT
        }
      } catch (err) {
        // Clear auth and redirect
      }
    }
    return Promise.reject(error);
  }
);
```

### 4. **Frontend - Logout Implementation MANQUANT**

**Probl√®me**: Le logout n'appelle pas l'API
- `AuthContext.logout()` ne call pas `/auth/logout`
- Il ne nettoie pas les refresh tokens en BD
- Le token reste valide en BD

**Fichier √† modifier**: `web-app/src/context/AuthContext.tsx`

**Code manquant**:
```typescript
const logout = async () => {
  try {
    await authService.logout(); // <- MANQUANT! Ne fait pas la requ√™te API
    await storage.clearAuth();
    setToken(null);
    setUser(null);
  } catch (error) {
    // ...
  }
};
```

**Fichier √† modifier**: `web-app/src/services/api.ts`

**Code manquant**:
```typescript
export const authService = {
  // ...
  logout: () => api.post('/auth/logout'), // <- MANQUANT!
};
```

### 5. **Frontend - Error Handling pour Expired Token MANQUANT**

**Probl√®me**: Pas de UI feedback quand token expire
- Utilisateur ne sait pas pourquoi √ßa ne fonctionne plus
- Pas de message "Session expir√©e, veuillez vous reconnecter"
- L'app silencieusement √©choue

**Fichier √† modifier**: `web-app/src/services/api.ts` et `web-app/src/context/AuthContext.tsx`

**Code manquant**:
```typescript
// Besoin d'une fonction pour notifier l'utilisateur
const notifySessionExpired = () => {
  Alert.alert(
    'Session expir√©e',
    'Votre session a expir√©. Veuillez vous reconnecter.',
    [{ text: 'OK', onPress: () => redirectToLogin() }]
  );
};
```

### 6. **Frontend - Organization ID in Header MANQUANT**

**Probl√®me**: Les requ√™tes n'envoient PAS l'organization_id
- Backend middleware `requireOrganization` l'attend
- Multi-tenancy ne fonctionne pas correctement
- Risque de data leak entre organisations

**Fichier √† modifier**: `web-app/src/services/api.ts`

**Code manquant**:
```typescript
api.interceptors.request.use(async (config) => {
  const token = await storage.getToken();
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  
  // MANQUANT:
  // const orgId = await storage.getOrgId();
  // if (orgId) {
  //   config.headers['X-Organization-Id'] = orgId;
  // }
  
  return config;
});
```

### 7. **Frontend - Token Expiry Proactive Check MANQUANT**

**Probl√®me**: Pas de v√©rification proactive de l'expiration
- Token expira sans pr√©vention
- Utilisateur ne peut pas se reconnecter avant
- Mauvaise UX

**Fichier √† cr√©er**: `web-app/src/utils/tokenManager.ts`

**Code manquant**:
```typescript
export const isTokenExpiringSoon = (token: string, bufferSeconds = 300) => {
  const decoded = jwtDecode(token);
  const expiresIn = decoded.exp * 1000 - Date.now();
  return expiresIn < bufferSeconds * 1000;
};

// √Ä utiliser dans un useEffect:
useEffect(() => {
  const checkTokenExpiry = async () => {
    const token = await storage.getToken();
    if (token && isTokenExpiringSoon(token)) {
      // Refresh token proactivement
      await refreshAccessToken();
    }
  };
  
  const interval = setInterval(checkTokenExpiry, 60000); // Check toutes les 60s
  return () => clearInterval(interval);
}, []);
```

### 8. **Frontend - Register ne stocke pas le refreshToken MANQUANT**

**Probl√®me**: L'enregistrement cr√©e un token mais ne le stocke pas compl√®tement

**Fichier √† modifier**: `web-app/src/context/AuthContext.tsx`

```typescript
const register = async (email, password, name) => {
  const response = await authService.register({ email, password, name });
  const { token, refreshToken } = response.data; // <- refreshToken re√ßu
  
  await storage.saveToken(token);
  // await storage.saveRefreshToken(refreshToken); <- MANQUANT!
  
  setToken(token);
  setUser(newUser);
};
```

### 9. **Frontend - TestAllScreen ne teste pas le refresh MANQUANT**

**Probl√®me**: Les tests n'incluent pas le flow de refresh

**Fichier √† modifier**: `web-app/src/screens/TestAllScreen.tsx`

**Code manquant**:
```typescript
// Ajouter test pour le refresh endpoint
await test(
  'POST /api/auth/refresh',
  async () => {
    const refreshToken = await storage.getRefreshToken();
    const response = await api.post('/api/auth/refresh', { refreshToken });
    return {
      message: '‚úì Token refreshed successfully',
      data: response.data,
    };
  },
  'Authentication'
);
```

### 10. **Frontend - Navigation/Redirection apr√®s Token Expiry MANQUANT**

**Probl√®me**: Pas de logique pour rediriger vers login apr√®s expiration

**Fichier √† modifier**: `web-app/src/services/api.ts`

**Code manquant**:
```typescript
const api = axios.create({...});

// Besoin d'une r√©f√©rence au navigation ou state manager
// pour rediriger quand session expire
```

---

## üéØ PLAN D'IMPL√âMENTATION

### PRIORIT√â 1 - CRITIQUE (Sans cela, rien ne fonctionne)
1. ‚úÖ Cr√©er `web-app/src/utils/tokenManager.ts`
   - Fonction `isTokenExpired()`
   - Fonction `isTokenExpiringSoon()`
   - Fonction `refreshAccessToken()`

2. ‚úÖ Modifier `web-app/src/utils/storage.ts`
   - Ajouter `saveRefreshToken()`, `getRefreshToken()`, `removeRefreshToken()`

3. ‚úÖ Modifier `web-app/src/context/AuthContext.tsx`
   - Stocker refreshToken dans login() et register()
   - Impl√©menter fonction `refreshToken()`
   - Ajouter logique de refresh automatique dans useEffect

4. ‚úÖ Modifier `web-app/src/services/api.ts`
   - Response interceptor utiliser refreshToken
   - POST /auth/refresh implementation
   - Retry logic apr√®s refresh

### PRIORIT√â 2 - IMPORTANT (Pour la qualit√©)
5. ‚úÖ Ajouter `logout()` √† `authService`
6. ‚úÖ Impl√©menter `/auth/logout` call dans `AuthContext.logout()`
7. ‚úÖ Ajouter tests pour refresh dans `TestAllScreen.tsx`
8. ‚úÖ Ajouter notifications d'erreur utilisateur

### PRIORIT√â 3 - BONUS (S√©curit√© avanc√©e)
9. Ajouter support pour Organization ID header
10. Ajouter proactive token refresh check
11. Impl√©menter token rotation strategy
12. Ajouter rate limiting sur refresh endpoint

---

## üìã R√©sum√© des Modifications N√©cessaires

| Fichier | Statut | Action | Lignes |
|---------|--------|--------|--------|
| `web-app/src/utils/tokenManager.ts` | ‚ùå NOUVEAU | Cr√©er | ~100 |
| `web-app/src/utils/storage.ts` | ‚ö†Ô∏è INCOMPLET | Ajouter refresh token methods | ~20 |
| `web-app/src/services/api.ts` | ‚ö†Ô∏è INCOMPLET | Ajouter refresh logic | ~50 |
| `web-app/src/context/AuthContext.tsx` | ‚ö†Ô∏è INCOMPLET | Ajouter refresh + logout | ~50 |
| `web-app/src/screens/TestAllScreen.tsx` | ‚ö†Ô∏è INCOMPLET | Ajouter tests refresh | ~20 |
| `api/src/routes/auth.ts` | ‚úÖ OK | Rien √† faire | - |
| `api/src/middleware/auth.ts` | ‚úÖ OK | Rien √† faire | - |

---

## üö® Probl√®me CRITIQUE Actuellement

**Situation**: 
- ‚úÖ Utilisateur se connecte (token re√ßu)
- ‚úÖ Token stock√© dans AsyncStorage
- ‚úÖ Interceptor ajoute token aux requ√™tes
- ‚ùå **Apr√®s 15 minutes**: Token expire
- ‚ùå **Requ√™te suivante**: 401 Unauthorized
- ‚ùå **Pas de refresh**: Utilisateur reste bloqu√©
- ‚ùå **Interceptor efface token**: Utilisateur redirig√© √† login

**R√©sultat**: Utilisateur ne peut pas utiliser l'app plus de 15 minutes!

---

## üìù Tests de Validation

Apr√®s impl√©mentation:

```bash
# 1. Se connecter
curl -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email": "test@simplix.local", "password": "Test123!Abc"}'

# 2. Attendre 16 minutes OU modifier l'expiry √† 10s dans .env
# JWT_EXPIRY=10s

# 3. Faire une requ√™te avec le token (sera 401)

# 4. Refresh le token
curl -X POST http://localhost:3000/api/auth/refresh \
  -H "Content-Type: application/json" \
  -d '{"refreshToken": "<refreshToken>"}'

# 5. Utiliser le nouveau token (doit fonctionner)
curl -X GET http://localhost:3000/api/customers \
  -H "Authorization: Bearer <newAccessToken>"
```

---

## üéì Architecture Compl√®te Apr√®s Impl√©mentation

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         Frontend (web-app)              ‚îÇ
‚îÇ                                         ‚îÇ
‚îÇ  LoginScreen                            ‚îÇ
‚îÇ       ‚Üì                                 ‚îÇ
‚îÇ  POST /auth/login                       ‚îÇ
‚îÇ       ‚Üì (re√ßoit accessToken + refreshToken)
‚îÇ  AsyncStorage.setItem(token, refresh)  ‚îÇ
‚îÇ       ‚Üì                                 ‚îÇ
‚îÇ  AuthContext { isAuthenticated=true }   ‚îÇ
‚îÇ       ‚Üì                                 ‚îÇ
‚îÇ  HomeScreen + API calls                 ‚îÇ
‚îÇ       ‚Üì                                 ‚îÇ
‚îÇ  Interceptor ajoute: Bearer token       ‚îÇ
‚îÇ       ‚Üì                                 ‚îÇ
‚îÇ  Si response 401:                       ‚îÇ
‚îÇ    - GET refreshToken d'AsyncStorage   ‚îÇ
‚îÇ    - POST /auth/refresh                 ‚îÇ
‚îÇ    - Mise √† jour accessToken            ‚îÇ
‚îÇ    - Retry requ√™te originale            ‚îÇ
‚îÇ    ‚Üì Si refresh 401:                    ‚îÇ
‚îÇ    - Clear AsyncStorage                 ‚îÇ
‚îÇ    - AuthContext { isAuthenticated=false}
‚îÇ    - Redirection LoginScreen            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚Üï HTTP Requests
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ        Backend API (Express)            ‚îÇ
‚îÇ                                         ‚îÇ
‚îÇ POST /auth/login                        ‚îÇ
‚îÇ   ‚Üì V√©rifier credentials                ‚îÇ
‚îÇ   ‚Üì G√©n√©rer accessToken (15m)           ‚îÇ
‚îÇ   ‚Üì G√©n√©rer refreshToken (7d)           ‚îÇ
‚îÇ   ‚Üì Stocker refreshToken en BD          ‚îÇ
‚îÇ   ‚Üì Retourner les deux tokens           ‚îÇ
‚îÇ                                         ‚îÇ
‚îÇ POST /auth/refresh                      ‚îÇ
‚îÇ   ‚Üì V√©rifier refreshToken               ‚îÇ
‚îÇ   ‚Üì G√©n√©rer nouveau accessToken         ‚îÇ
‚îÇ   ‚Üì Retourner nouveau token             ‚îÇ
‚îÇ                                         ‚îÇ
‚îÇ GET /api/* (prot√©g√©e)                   ‚îÇ
‚îÇ   ‚Üì Middleware v√©rifie accessToken      ‚îÇ
‚îÇ   ‚Üì Si valide: req.user = {id, email}   ‚îÇ
‚îÇ   ‚Üì Si invalide: 401 Unauthorized       ‚îÇ
‚îÇ                                         ‚îÇ
‚îÇ POST /auth/logout                       ‚îÇ
‚îÇ   ‚Üì Supprimer refreshToken de BD        ‚îÇ
‚îÇ   ‚Üì Retourner success                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚Üï PostgreSQL
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           Database                      ‚îÇ
‚îÇ                                         ‚îÇ
‚îÇ users { id, email, password_hash }      ‚îÇ
‚îÇ refresh_tokens { user_id, token, exp }  ‚îÇ
‚îÇ                                         ‚îÇ
‚îÇ Lors du logout: DELETE refresh_tokens   ‚îÇ
‚îÇ Lors du refresh: UPDATE refresh_tokens  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```
