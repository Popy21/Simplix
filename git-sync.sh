#!/bin/bash

# Script de synchronisation Git automatique AVANC√â - Travail en √©quipe
# G√®re: stash, overwrites, conflicts, protections, et garde tout sur main
# Version: 2.0 - Safe Team Mode

set -e

# Couleurs
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m'

echo -e "${CYAN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
echo -e "${CYAN}‚ïë       üîÑ Git Sync - Mode √âquipe S√©curis√© v2.0             ‚ïë${NC}"
echo -e "${CYAN}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
echo ""

# V√©rifier si on est dans un d√©p√¥t Git
if ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo -e "${RED}‚ùå Erreur: Pas dans un d√©p√¥t Git${NC}"
    exit 1
fi

# Fonction de d√©tection de suppressions massives
check_dangerous_deletions() {
    local deleted_count=$(git status --short | grep -c "^ D" || true)
    local total_files=$(git ls-files | wc -l | tr -d ' ')
    
    if [ "$deleted_count" -gt 10 ]; then
        echo -e "${RED}‚ö†Ô∏è  ALERTE: $deleted_count fichiers supprim√©s d√©tect√©s !${NC}"
        echo -e "${YELLOW}Fichiers supprim√©s:${NC}"
        git status --short | grep "^ D" | head -20
        
        if [ "$deleted_count" -gt 20 ]; then
            echo -e "${YELLOW}... et $(($deleted_count - 20)) autres fichiers${NC}"
        fi
        
        echo ""
        echo -e "${RED}‚ö†Ô∏è  DANGER: Suppression massive d√©tect√©e !${NC}"
        echo -e "${YELLOW}Cela pourrait √™tre une erreur (ex: git rm, mv mal ex√©cut√©)${NC}"
        echo ""
        read -p "√ätes-vous S√õR de vouloir supprimer ces fichiers ? Tapez 'DELETE' pour confirmer: " confirm
        
        if [ "$confirm" != "DELETE" ]; then
            echo -e "${GREEN}‚úÖ Synchronisation annul√©e pour votre s√©curit√©${NC}"
            echo -e "${BLUE}üí° Conseil: V√©rifiez avec 'git status' ce qui a √©t√© supprim√©${NC}"
            echo -e "${BLUE}üí° Pour restaurer: git restore <fichier> ou git restore .${NC}"
            exit 0
        fi
    fi
}

# Fonction de v√©rification de l'identit√© Git
check_git_identity() {
    local git_name=$(git config user.name || echo "")
    local git_email=$(git config user.email || echo "")
    
    if [ -z "$git_name" ] || [ -z "$git_email" ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  Configuration Git incompl√®te${NC}"
        echo ""
        
        if [ -z "$git_name" ]; then
            read -p "Votre nom complet: " git_name
            git config --global user.name "$git_name"
        fi
        
        if [ -z "$git_email" ]; then
            read -p "Votre email: " git_email
            git config --global user.email "$git_email"
        fi
        
        echo -e "${GREEN}‚úì Identit√© configur√©e: $git_name <$git_email>${NC}"
        echo ""
    fi
}

# Fonction de backup automatique avant op√©rations dangereuses
create_backup_branch() {
    local backup_name="backup-$(date '+%Y%m%d-%H%M%S')"
    git branch "$backup_name" 2>/dev/null || true
    echo -e "${BLUE}üíæ Backup cr√©√©: $backup_name${NC}"
}

# Fonction de nettoyage des vieux backups (garde les 5 derniers)
cleanup_old_backups() {
    local backup_count=$(git branch | grep -c "backup-" || true)
    if [ "$backup_count" -gt 5 ]; then
        echo -e "${BLUE}üßπ Nettoyage des anciens backups...${NC}"
        git branch | grep "backup-" | head -n $(($backup_count - 5)) | xargs -r git branch -D 2>/dev/null || true
    fi
}

# V√©rifier l'identit√© Git
check_git_identity

# S'assurer qu'on est sur main
CURRENT_BRANCH=$(git branch --show-current)
if [ "$CURRENT_BRANCH" != "main" ]; then
    echo -e "${YELLOW}‚ö†Ô∏è  Vous √™tes sur la branche '$CURRENT_BRANCH'${NC}"
    read -p "Voulez-vous passer sur 'main' ? (y/n) [y]: " switch_branch
    switch_branch=${switch_branch:-y}

    if [ "$switch_branch" = "y" ]; then
        echo -e "${BLUE}üìç Passage sur la branche main...${NC}"

        # Sauvegarder les modifications locales
        if [[ -n $(git status -s) ]]; then
            echo -e "${YELLOW}üíæ Sauvegarde des modifications locales (stash)...${NC}"
            git stash push -m "Auto-stash before switching to main $(date '+%Y-%m-%d %H:%M:%S')"
        fi

        git checkout main

        # Restaurer le stash si besoin
        if git stash list | grep -q "Auto-stash before switching to main"; then
            echo -e "${BLUE}üì• Restauration des modifications...${NC}"
            git stash pop
        fi
    else
        echo -e "${RED}‚ùå Synchronisation annul√©e${NC}"
        exit 1
    fi
fi

echo -e "${GREEN}‚úì Sur la branche main${NC}"
echo ""

# Configurer Git pour toujours merger (pas de rebase par d√©faut)
git config pull.rebase false 2>/dev/null || true

# R√©cup√©rer les informations du remote
echo -e "${BLUE}üåê R√©cup√©ration des informations du remote...${NC}"
git fetch origin main 2>/dev/null || {
    echo -e "${RED}‚ùå Erreur lors de la r√©cup√©ration du remote${NC}"
    echo -e "${YELLOW}V√©rifiez votre connexion internet ou les permissions GitHub${NC}"
    exit 1
}

# V√©rifier s'il y a des modifications locales
HAS_LOCAL_CHANGES=false
if [[ -n $(git status -s) ]]; then
    echo -e "${YELLOW}üìù Modifications locales d√©tect√©es${NC}"
    HAS_LOCAL_CHANGES=true

    # PROTECTION: V√©rifier les suppressions massives
    check_dangerous_deletions

    # Afficher un r√©sum√© des modifications
    echo ""
    echo -e "${CYAN}R√©sum√© des modifications:${NC}"
    added=$(git status --short | grep -c "^??" || true)
    modified=$(git status --short | grep -c "^ M" || true)
    deleted=$(git status --short | grep -c "^ D" || true)
    
    echo -e "${GREEN}  ‚úì Ajout√©s: $added fichiers${NC}"
    echo -e "${BLUE}  ‚úì Modifi√©s: $modified fichiers${NC}"
    [ "$deleted" -gt 0 ] && echo -e "${YELLOW}  ‚ö†Ô∏è  Supprim√©s: $deleted fichiers${NC}"
    
    echo ""
    echo -e "${CYAN}D√©tails des modifications:${NC}"
    git status --short | head -20
    
    total_changes=$(git status --short | wc -l | tr -d ' ')
    if [ "$total_changes" -gt 20 ]; then
        echo -e "${YELLOW}... et $(($total_changes - 20)) autres modifications${NC}"
    fi
    echo ""
else
    echo -e "${GREEN}‚úì Pas de modifications locales${NC}"
fi

# Comparer avec le remote
LOCAL=$(git rev-parse main)
REMOTE=$(git rev-parse origin/main 2>/dev/null)
BASE=$(git merge-base main origin/main 2>/dev/null)

if [ -z "$REMOTE" ]; then
    echo -e "${RED}‚ùå Erreur: Pas de branche remote 'origin/main'${NC}"
    exit 1
fi

echo ""
echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"

# CAS 1: D√©j√† √† jour avec le remote
if [ "$LOCAL" = "$REMOTE" ]; then
    echo -e "${GREEN}‚úì D√©j√† √† jour avec origin/main${NC}"

    if [ "$HAS_LOCAL_CHANGES" = true ]; then
        echo ""
        echo -e "${YELLOW}üì§ Vous avez des modifications locales √† push${NC}"
        echo ""
        
        # Afficher l'auteur du dernier commit remote pour info
        last_author=$(git log origin/main -1 --pretty=format:"%an" 2>/dev/null || echo "inconnu")
        echo -e "${CYAN}üí° Dernier commit sur le remote par: $last_author${NC}"
        echo ""
        
        read -p "Message de commit: " commit_msg

        if [ -z "$commit_msg" ]; then
            commit_msg="Update $(date '+%Y-%m-%d %H:%M:%S')"
        fi

        echo -e "${BLUE}üíæ Commit des modifications...${NC}"
        git add .
        git commit -m "$commit_msg"

        echo -e "${BLUE}üì§ Push vers origin/main...${NC}"
        
        # V√©rifier une derni√®re fois qu'on est toujours √† jour avant de push
        git fetch origin main 2>/dev/null
        if [ "$(git rev-parse main)" != "$(git rev-parse origin/main)" ]; then
            echo -e "${YELLOW}‚ö†Ô∏è  Le remote a chang√© pendant votre commit !${NC}"
            echo -e "${BLUE}Relancer le script pour synchroniser correctement${NC}"
            exit 0
        fi
        
        if git push origin main; then
            echo -e "${GREEN}‚úÖ Modifications push√©es avec succ√®s${NC}"
        else
            echo -e "${RED}‚ùå Erreur lors du push${NC}"
            echo -e "${YELLOW}Quelqu'un d'autre a peut-√™tre push en m√™me temps${NC}"
            echo -e "${BLUE}Relancer le script pour synchroniser${NC}"
            exit 1
        fi
    else
        echo -e "${GREEN}‚úÖ Rien √† faire, tout est synchronis√©${NC}"
    fi

# CAS 2: En retard (besoin de pull)
elif [ "$LOCAL" = "$BASE" ]; then
    echo -e "${YELLOW}üì• Vous √™tes en retard par rapport au remote${NC}"
    
    # Afficher qui a fait les derniers commits
    echo ""
    echo -e "${CYAN}üìä Derniers commits sur le remote:${NC}"
    git log --oneline origin/main..main --reverse 2>/dev/null || git log --oneline origin/main -3
    echo ""

    # S'il y a des modifications locales, cr√©er un backup puis les commit
    if [ "$HAS_LOCAL_CHANGES" = true ]; then
        echo -e "${YELLOW}üíæ Sauvegarde automatique avant pull...${NC}"
        create_backup_branch
        
        echo ""
        echo -e "${YELLOW}üíæ Commit des modifications locales avant pull...${NC}"
        echo ""
        read -p "Message de commit: " commit_msg

        if [ -z "$commit_msg" ]; then
            commit_msg="WIP: Auto-commit before pull $(date '+%Y-%m-%d %H:%M:%S')"
        fi

        git add .
        git commit -m "$commit_msg"
        echo -e "${GREEN}‚úì Modifications committ√©es${NC}"
    fi

    echo ""
    echo -e "${BLUE}üì• Pull des modifications distantes...${NC}"

    # Pull avec merge automatique
    if git pull origin main --no-edit; then
        echo -e "${GREEN}‚úÖ Pull r√©ussi !${NC}"
        cleanup_old_backups
    else
        echo -e "${RED}‚ùå Conflit d√©tect√© lors du pull${NC}"
        echo ""
        echo -e "${YELLOW}üîß R√©solution des conflits...${NC}"
        echo ""

        # Afficher les fichiers en conflit
        echo -e "${CYAN}Fichiers en conflit:${NC}"
        git diff --name-only --diff-filter=U
        echo ""
        
        echo -e "${MAGENTA}Options de r√©solution:${NC}"
        echo "  1) Garder VOS modifications (--ours)"
        echo "  2) Garder les modifications DISTANTES (--theirs)"
        echo "  3) Annuler le merge et r√©soudre manuellement"
        echo ""
        read -p "Votre choix (1-3) [3]: " conflict_choice
        conflict_choice=${conflict_choice:-3}

        case $conflict_choice in
            1)
                echo -e "${YELLOW}üìù Acceptation de vos modifications locales...${NC}"
                git checkout --ours .
                git add .
                git commit -m "Merge: Keep local changes $(date '+%Y-%m-%d %H:%M:%S')"
                echo -e "${GREEN}‚úÖ Conflits r√©solus (vos modifications gard√©es)${NC}"
                cleanup_old_backups
                ;;
            2)
                echo -e "${YELLOW}üìù Acceptation des modifications distantes...${NC}"
                git checkout --theirs .
                git add .
                git commit -m "Merge: Keep remote changes $(date '+%Y-%m-%d %H:%M:%S')"
                echo -e "${GREEN}‚úÖ Conflits r√©solus (modifications distantes gard√©es)${NC}"
                cleanup_old_backups
                ;;
            *)
                echo -e "${YELLOW}‚ùå Merge annul√© - r√©solution manuelle n√©cessaire${NC}"
                echo ""
                echo -e "${CYAN}Commandes utiles:${NC}"
                echo "  git status                    # Voir les conflits"
                echo "  git diff                      # Voir les diff√©rences"
                echo "  git checkout --ours fichier   # Garder votre version"
                echo "  git checkout --theirs fichier # Garder la version distante"
                echo "  git add <fichier>             # Marquer comme r√©solu"
                echo "  git commit                    # Finaliser le merge"
                echo "  git merge --abort             # Annuler compl√®tement"
                echo ""
                echo -e "${BLUE}üí° Backup disponible dans la branche backup-*${NC}"
                git branch | grep "backup-" | tail -1
                exit 1
                ;;
        esac
    fi

# CAS 3: En avance (besoin de push)
elif [ "$REMOTE" = "$BASE" ]; then
    echo -e "${BLUE}üì§ Vous √™tes en avance par rapport au remote${NC}"

    # S'il y a des modifications non commit√©es
    if [ "$HAS_LOCAL_CHANGES" = true ]; then
        echo ""
        echo -e "${YELLOW}üíæ Commit des modifications...${NC}"
        echo ""
        read -p "Message de commit: " commit_msg

        if [ -z "$commit_msg" ]; then
            commit_msg="Update $(date '+%Y-%m-%d %H:%M:%S')"
        fi

        git add .
        git commit -m "$commit_msg"
        echo -e "${GREEN}‚úì Modifications committ√©es${NC}"
    fi

    echo ""
    echo -e "${BLUE}üì§ Push vers origin/main...${NC}"
    git push origin main
    echo -e "${GREEN}‚úÖ Push r√©ussi !${NC}"

# CAS 4: Divergence (historiques diff√©rents)
else
    echo -e "${RED}‚ö†Ô∏è  DIVERGENCE D√âTECT√âE${NC}"
    echo ""
    echo -e "${YELLOW}Vos commits locaux et les commits distants ont diverg√©.${NC}"
    echo -e "${YELLOW}Cela arrive quand plusieurs personnes travaillent en parall√®le.${NC}"
    echo ""

    # Cr√©er un backup automatique
    create_backup_branch
    echo ""

    # Afficher les commits divergents avec auteurs
    echo -e "${CYAN}üìä Vos commits locaux (absents du remote):${NC}"
    git log --oneline --pretty=format:"%h %an: %s" origin/main..main | head -5
    echo ""
    echo ""
    echo -e "${CYAN}üìä Commits distants (absents en local):${NC}"
    git log --oneline --pretty=format:"%h %an: %s" main..origin/main | head -5
    echo ""
    echo ""

    # Commit les modifications locales si n√©cessaire
    if [ "$HAS_LOCAL_CHANGES" = true ]; then
        echo -e "${YELLOW}üíæ Commit des modifications locales d'abord...${NC}"
        echo ""
        read -p "Message de commit: " commit_msg

        if [ -z "$commit_msg" ]; then
            commit_msg="WIP: Auto-commit $(date '+%Y-%m-%d %H:%M:%S')"
        fi

        git add .
        git commit -m "$commit_msg"
        echo -e "${GREEN}‚úì Modifications committ√©es${NC}"
        echo ""
    fi

    echo -e "${MAGENTA}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${MAGENTA}‚ïë           Choisissez la strat√©gie de r√©solution            ‚ïë${NC}"
    echo -e "${MAGENTA}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    echo ""
    echo -e "${CYAN}Recommand√© pour le travail en √©quipe:${NC}"
    echo "  ${GREEN}2) Merge${NC} - Combine les deux historiques (RECOMMAND√â)"
    echo "     ‚úì Pr√©serve tout l'historique"
    echo "     ‚úì S√ªr pour le travail collaboratif"
    echo ""
    echo -e "${YELLOW}Options avanc√©es:${NC}"
    echo "  ${BLUE}3) Rebase${NC} - Applique vos commits apr√®s le remote"
    echo "     ‚ö†Ô∏è  R√©√©crit l'historique (peut √™tre dangereux)"
    echo ""
    echo "  ${RED}1) Force Push${NC} - √âCRASER le remote avec vos changements"
    echo "     ‚ö†Ô∏è  DANGER: Supprime le travail des autres !"
    echo ""
    echo "  4) Annuler et r√©soudre manuellement"
    echo ""
    read -p "Votre choix (1-4) [2]: " strategy
    strategy=${strategy:-2}

    case $strategy in
        1)
            echo ""
            echo -e "${RED}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
            echo -e "${RED}‚ïë                    ‚ö†Ô∏è  DANGER CRITIQUE ‚ö†Ô∏è                  ‚ïë${NC}"
            echo -e "${RED}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
            echo ""
            echo -e "${RED}Cela va √âCRASER d√©finitivement les modifications distantes !${NC}"
            echo -e "${YELLOW}Tous les commits de vos coll√®gues seront PERDUS !${NC}"
            echo ""
            echo -e "${CYAN}Commits qui seront SUPPRIM√âS du remote:${NC}"
            git log --oneline --pretty=format:"%h %an: %s" main..origin/main
            echo ""
            echo ""
            read -p "Avez-vous PR√âVENU votre √©quipe ? (y/n) [n]: " team_notified
            
            if [ "$team_notified" != "y" ]; then
                echo -e "${YELLOW}‚ö†Ô∏è  Pr√©venez d'abord votre √©quipe avant de force push !${NC}"
                echo -e "${RED}Force push annul√© pour prot√©ger le travail de l'√©quipe${NC}"
                exit 1
            fi
            
            read -p "Tapez exactement 'FORCE PUSH' pour confirmer: " confirm

            if [ "$confirm" = "FORCE PUSH" ]; then
                echo -e "${YELLOW}üí™ Force push vers origin/main...${NC}"
                if git push --force origin main; then
                    echo -e "${GREEN}‚úÖ Push forc√© r√©ussi (remote √©cras√©)${NC}"
                    echo -e "${YELLOW}‚ö†Ô∏è  Pr√©venez imm√©diatement votre √©quipe de faire un 'git pull --force'${NC}"
                    cleanup_old_backups
                else
                    echo -e "${RED}‚ùå Erreur lors du force push${NC}"
                    exit 1
                fi
            else
                echo -e "${RED}‚ùå Confirmation incorrecte - force push annul√©${NC}"
                echo -e "${GREEN}‚úÖ Travail de l'√©quipe pr√©serv√©${NC}"
                exit 1
            fi
            ;;
        2)
            echo -e "${BLUE}üîÄ Merge des branches (recommand√© pour l'√©quipe)...${NC}"
            if git pull origin main --no-edit; then
                echo -e "${GREEN}‚úÖ Merge r√©ussi automatiquement${NC}"
                echo -e "${BLUE}üì§ Push du r√©sultat...${NC}"
                git push origin main
                echo -e "${GREEN}‚úÖ Synchronisation compl√®te${NC}"
                cleanup_old_backups
            else
                echo -e "${RED}‚ùå Conflit lors du merge${NC}"
                echo ""
                echo -e "${MAGENTA}R√©solution des conflits:${NC}"
                echo "  1) Garder VOS modifications"
                echo "  2) Garder les modifications DISTANTES"
                echo "  3) Annuler et r√©soudre manuellement"
                echo ""
                read -p "Votre choix (1-3) [3]: " merge_choice
                merge_choice=${merge_choice:-3}

                case $merge_choice in
                    1)
                        git checkout --ours .
                        git add .
                        git commit -m "Merge: Keep local changes (team sync)"
                        git push origin main
                        echo -e "${GREEN}‚úÖ Conflits r√©solus (vos modifs gard√©es)${NC}"
                        cleanup_old_backups
                        ;;
                    2)
                        git checkout --theirs .
                        git add .
                        git commit -m "Merge: Keep remote changes (team sync)"
                        git push origin main
                        echo -e "${GREEN}‚úÖ Conflits r√©solus (modifs distantes gard√©es)${NC}"
                        cleanup_old_backups
                        ;;
                    *)
                        echo -e "${YELLOW}Merge annul√© - r√©solution manuelle${NC}"
                        echo -e "${BLUE}üí° Backup disponible:${NC}"
                        git branch | grep "backup-" | tail -1
                        exit 1
                        ;;
                esac
            fi
            ;;
        3)
            echo -e "${BLUE}üîÑ Rebase sur origin/main...${NC}"
            echo -e "${YELLOW}‚ö†Ô∏è  Le rebase r√©√©crit l'historique${NC}"
            if git pull --rebase origin main; then
                echo -e "${GREEN}‚úÖ Rebase r√©ussi${NC}"
                echo -e "${BLUE}üì§ Push des modifications...${NC}"
                git push origin main
                echo -e "${GREEN}‚úÖ Push r√©ussi${NC}"
                cleanup_old_backups
            else
                echo -e "${RED}‚ùå Conflit lors du rebase${NC}"
                echo ""
                echo -e "${CYAN}R√©solution manuelle n√©cessaire:${NC}"
                echo "  1. R√©solvez les conflits dans les fichiers"
                echo "  2. git add <fichiers-r√©solus>"
                echo "  3. git rebase --continue"
                echo "  4. git push origin main"
                echo ""
                echo -e "${YELLOW}Ou annulez avec: git rebase --abort${NC}"
                echo -e "${BLUE}üí° Backup disponible:${NC}"
                git branch | grep "backup-" | tail -1
                exit 1
            fi
            ;;
        4|*)
            echo -e "${YELLOW}‚ùå Synchronisation annul√©e${NC}"
            echo -e "${BLUE}üí° Backup cr√©√©:${NC}"
            git branch | grep "backup-" | tail -1
            echo ""
            echo -e "${CYAN}Pour synchroniser manuellement plus tard:${NC}"
            echo "  ./git-sync.sh"
            exit 0
            ;;
    esac
fi

echo ""
echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
echo -e "${GREEN}üéâ Synchronisation termin√©e avec succ√®s !${NC}"
echo ""

# Afficher le statut final
echo -e "${CYAN}üìä Statut final:${NC}"
git status --short --branch
echo ""

# Afficher les derniers commits pour info
echo -e "${CYAN}üìú Derniers commits:${NC}"
git log --oneline --pretty=format:"%C(yellow)%h%C(reset) %C(cyan)%an%C(reset): %s" -5
echo ""
echo ""

echo -e "${GREEN}‚úÖ Vous √™tes sur 'main' et synchronis√© avec le remote${NC}"

# Afficher les backups disponibles si il y en a
backup_count=$(git branch | grep -c "backup-" || true)
if [ "$backup_count" -gt 0 ]; then
    echo -e "${BLUE}üíæ $backup_count backup(s) disponible(s) en cas de besoin${NC}"
    echo -e "${CYAN}   Pour voir: git branch | grep backup${NC}"
fi

echo ""
echo -e "${MAGENTA}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
echo -e "${MAGENTA}‚ïë    ü§ù Pensez √† communiquer avec votre √©quipe ! ü§ù         ‚ïë${NC}"
echo -e "${MAGENTA}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
